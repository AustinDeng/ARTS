# 回溯法


回溯法是经典的算法之一，与其他算法(动态规划，贪心，分治等)相比，比较简单。

在维基百科里是这么介绍的：

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案
- 在尝试了所有可能的分步方法后宣告该问题没有答案

## 思想

回溯法也被称为暴力搜索法，是通过遍历所有可能的结果，进而判断结果是否符合预期条件而达到求解的过程。

基本的思想就是将所有解抽象为一颗树形结构，每一个结点都是当前问题的一个解（可能是无效的），采用`深度优先遍历`(dfs)的策略去一个个检验当前结点是否符合条件，符合则继续遍历直到叶子节点，若不符合则回溯到当前分支根去遍历另外一个分支，直到整个解空间都被遍历完为止。

## 步骤

1. 分析问题，确定解的空间，进而确定解空间树的模式(包含了问题的的所有结果)
2. 分析结点，确定判断条件，确定拓展的搜索规则
3. 以深度优先遍历算法去搜索整个树，找到其中的有效解

## 解题框架

设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。

### 非递归法

```
int a[n],i;
初始化数组a[];
i = 1;
while (i>0(有路可走) and (未达到目标))   // 还未回溯到头
{
    if(i > n)                                              // 搜索到叶结点
     {   
          搜索到一个解，输出；
     }
    else                                                   // 处理第i个元素
     { 
           a[i]第一个可能的值；
           while(a[i]在不满足约束条件且在搜索空间内)
           {
               a[i]下一个可能的值；
           }
           if(a[i]在搜索空间内)
          {
               标识占用的资源；
               i = i+1;                              // 扩展下一个结点
          }
          else 
         {
               清理所占的状态空间；            // 回溯
               i = i –1; 
          }
}
```

### 递归法

```
int a[n];
 try(int i)
{
    if(i>n)
       输出结果;
    else
    {
       for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
       {
           if(fun(j))                 // 满足限界函数和约束条件
             {
                a[i] = j;
              ...                         // 其他操作
                try(i+1);
              回溯前的清理工作（如a[i]置空值等）;
              }
         }
      }
 }
```

## 算法实例

- 八皇后
- N皇后
- 二进制手表


参考：　https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html